# 一、实现秒杀功能

- 简单实现									/createWrongOrder/{sid}

- 乐观锁实现 + 令牌桶限流          /createOptimisticOrder/{sid}

- 悲观锁实现                               /createPessimisticOrder/{sid}


乐观锁不加限流 	好处是适合高并发的情况，但是容易出现抢购失败的情况，即1000个商品1200个人抢，但是只卖出600份情况

悲观锁 	好处是不容易出现像乐观锁那种抢购失败的情况。但是在高并发的情况下可能会让用户阻塞等待太久。

悲观锁 + 令牌桶限流 	既可以快速失败，不至于让用户等太久，同时也不容易出现抢购失败

# 二、抢购接口隐藏及单用户限制频率

## 使用验证码给爬虫增加难度

1. 每次点击秒杀按钮，先从服务器获取一个秒杀验证值（到了抢购开启时间才能获取验证码，在一定程度上防止刷单）	
2. Redis以缓存用户ID和商品ID为Key，秒杀地址为Value缓存验证值（Key使用加盐SALT的得到）
3. 用户请求秒杀商品的时候，要带上秒杀验证值进行校验。

**以上三步其实并没有什么用，如果爬虫写复杂一点，先获取验证码再抢购，写了跟没写一样**

- 获取验证码                                        /getVerifyHash + sid + userId

- 需要验证的抢购接口                         /createOrderWithVerifiedUrl + sid + userId + verifyHash

## 单用户访问限制

- 用户带上验证码秒杀商品时，记录用户一段时间内访问了多少次~~本商品~~，设置了过期时间		

/createOrderWithVerifiedUrlAndLimit + sid + userId + verifyHash

# 三、将库存读入缓存并保持数据库及缓存一致性

**将库存读入缓存并不合适，因为库存需要频繁更改**，而更新，而更新操作必须要保证数据库和缓存的同步，频繁的写入数据库效率并没有提高。故而缓存适用于评论、介绍之类的不会频繁更改的数据。这里以库存为例，尝试将库存存入缓存。

- 从数据库中读取数据																				/getStockByDB/{sid}

- 先通过缓存查询，如果没有查到则通过数据库查询，并且写入缓存		/getStockByCache/{sid}

## 如何实现数据库与缓存的同步

上面只是涉及读，没有同步的问题。但是如果有更新操作就要考虑同步了，更新缓存不安全（脏数据）、性能也不好

1. ### 先删缓存，再更新数据库

    好处在于就算更新数据库这一步失败了，也只是到数据库中重读一次

    - ​								/createOrderWithCacheV1/{sid}

2. ### 先更新数据库，再删缓存

    由于写入数据库的速度慢，读数据库的速度快所以使得这种方式更不容易出现并发错误

    - ​								/createOrderWithCacheV2/{sid}

3. ### 缓存延时双删

    以上两种方法都不能从根本上解决缓存中脏数据的现象，所以一种更保险的方法就是先删除缓存，再更新数据，等待一段时间后再删除缓存，以避免在写的过程中，产生的脏数据。------>等待并删除的步骤，如果写入业务代码的化会使得吞吐量下降，所以可以开启一个新的线程来执行

    - ​								/createOrderWithCacheV3/{sid}

4. ### 使用rabbitMQ防止删除失败

   /createOrderWithCacheV4/{sid}

